// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5 (swiftlang-1300.0.31.1 clang-1300.0.29.1)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name AesGcmNoPadding
@_exported import AesGcmNoPadding
import CommonCrypto
import Compression
import CoreFoundation
import CryptoKit
import Foundation
import Swift
import _Concurrency
import zlib
public struct QKMRZResult {
  public let documentType: Swift.String
  public let countryCode: Swift.String
  public let surnames: Swift.String
  public let givenNames: Swift.String
  public let documentNumber: Swift.String
  public let nationalityCountryCode: Swift.String
  public let birthdate: Foundation.Date?
  public let sex: Swift.String?
  public let expiryDate: Foundation.Date?
  public let personalNumber: Swift.String
  public let personalNumber2: Swift.String?
  public let isDocumentNumberValid: Swift.Bool
  public let isBirthdateValid: Swift.Bool
  public let isExpiryDateValid: Swift.Bool
  public let isPersonalNumberValid: Swift.Bool?
  public let allCheckDigitsValid: Swift.Bool
}
public struct Entry : Swift.Equatable {
  public enum EntryType : Swift.Int {
    case file
    case directory
    case symlink
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func path(using encoding: Swift.String.Encoding) -> Swift.String
  public var path: Swift.String {
    get
  }
  public var fileAttributes: [Foundation.FileAttributeKey : Any] {
    get
  }
  public var checksum: AesGcmNoPadding.CRC32 {
    get
  }
  public var type: AesGcmNoPadding.Entry.EntryType {
    get
  }
  public var isCompressed: Swift.Bool {
    get
  }
  public var compressedSize: Swift.UInt64 {
    get
  }
  public var uncompressedSize: Swift.UInt64 {
    get
  }
  public static func == (lhs: AesGcmNoPadding.Entry, rhs: AesGcmNoPadding.Entry) -> Swift.Bool
}
extension AesGcmNoPadding.Archive {
  final public func extract(_ entry: AesGcmNoPadding.Entry, to url: Foundation.URL, bufferSize: Swift.Int = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil) throws -> AesGcmNoPadding.CRC32
  final public func extract(_ entry: AesGcmNoPadding.Entry, bufferSize: Swift.Int = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> AesGcmNoPadding.CRC32
}
extension AesGcmNoPadding.Archive {
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: AesGcmNoPadding.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, fileURL: Foundation.URL, compressionMethod: AesGcmNoPadding.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, type: AesGcmNoPadding.Entry.EntryType, uncompressedSize: Swift.Int64, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: AesGcmNoPadding.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data) throws
  final public func remove(_ entry: AesGcmNoPadding.Entry, bufferSize: Swift.Int = defaultReadChunkSize, progress: Foundation.Progress? = nil) throws
}
@_inheritsConvenienceInitializers @objc open class AesGcmNoPaddingAlgorith : ObjectiveC.NSObject {
  @objc open func decryptWith(uniqueKeyId: Swift.String, publicKey: Swift.String, encryptedData: Foundation.Data) -> Foundation.Data?
  @objc open func zipURL(sourceURL: Foundation.URL, destinationURL: Foundation.URL) -> Swift.Bool
  @objc open func parseMrz(strings: [Swift.String]) -> AesGcmNoPadding.MRZResult?
  @objc override dynamic public init()
  @objc deinit
}
extension Foundation.Data {
  @available(*, deprecated, message: "Please use `Int64` for `size` and provider `position`.")
  public static func compress(size: Swift.Int, bufferSize: Swift.Int, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> AesGcmNoPadding.CRC32
  @available(*, deprecated, message: "Please use `Int64` for `size` and provider `position`.")
  public static func decompress(size: Swift.Int, bufferSize: Swift.Int, skipCRC32: Swift.Bool, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> AesGcmNoPadding.CRC32
}
public typealias FILEPointer = Swift.UnsafeMutablePointer<Darwin.FILE>
public enum CompressionMethod : Swift.UInt16 {
  case none
  case deflate
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public typealias CRC32 = Swift.UInt32
public typealias Consumer = (_ data: Foundation.Data) throws -> Swift.Void
public typealias Provider = (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data
extension Foundation.Data {
  public func crc32(checksum: AesGcmNoPadding.CRC32) -> AesGcmNoPadding.CRC32
  public static func compress(size: Swift.Int64, bufferSize: Swift.Int, provider: (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> AesGcmNoPadding.CRC32
  public static func decompress(size: Swift.Int64, bufferSize: Swift.Int, skipCRC32: Swift.Bool, provider: (_ position: Swift.Int64, _ size: Swift.Int) throws -> Foundation.Data, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> AesGcmNoPadding.CRC32
}
extension AesGcmNoPadding.Archive {
  final public var data: Foundation.Data? {
    get
  }
}
public var defaultReadChunkSize: Swift.Int
public var defaultWriteChunkSize: Swift.Int
public var defaultFilePermissions: Swift.UInt16
public var defaultDirectoryPermissions: Swift.UInt16
final public class Archive : Swift.Sequence {
  public enum ArchiveError : Swift.Error {
    case unreadableArchive
    case unwritableArchive
    case invalidEntryPath
    case invalidCompressionMethod
    case invalidCRC32
    case cancelledOperation
    case invalidBufferSize
    case invalidEntrySize
    case invalidLocalHeaderDataOffset
    case invalidLocalHeaderSize
    case invalidCentralDirectoryOffset
    case invalidCentralDirectorySize
    case invalidCentralDirectoryEntryCount
    case missingEndOfCentralDirectoryRecord
    public static func == (a: AesGcmNoPadding.Archive.ArchiveError, b: AesGcmNoPadding.Archive.ArchiveError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AccessMode : Swift.UInt {
    case create
    case read
    case update
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  final public let url: Foundation.URL
  final public let accessMode: AesGcmNoPadding.Archive.AccessMode
  public init?(url: Foundation.URL, accessMode mode: AesGcmNoPadding.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  public init?(data: Foundation.Data = Data(), accessMode mode: AesGcmNoPadding.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  @objc deinit
  final public func makeIterator() -> Swift.AnyIterator<AesGcmNoPadding.Entry>
  final public subscript(path: Swift.String) -> AesGcmNoPadding.Entry? {
    get
  }
  public typealias Element = AesGcmNoPadding.Entry
  public typealias Iterator = Swift.AnyIterator<AesGcmNoPadding.Entry>
}
public class QKMRZParser {
  public init(ocrCorrection: Swift.Bool = false)
  public func parse(mrzLines: [Swift.String]) -> AesGcmNoPadding.QKMRZResult?
  public func parse(mrzString: Swift.String) -> AesGcmNoPadding.QKMRZResult?
  @objc deinit
}
extension AesGcmNoPadding.Archive {
  final public func totalUnitCountForRemoving(_ entry: AesGcmNoPadding.Entry) -> Swift.Int64
  final public func totalUnitCountForReading(_ entry: AesGcmNoPadding.Entry) -> Swift.Int64
  final public func totalUnitCountForAddingItem(at url: Foundation.URL) -> Swift.Int64
}
@_hasMissingDesignatedInitializers @objc public class MRZResult : ObjectiveC.NSObject {
  @objc final public let ocrText: Swift.String
  @objc final public let documentType: Swift.String
  @objc final public let countryCode: Swift.String
  @objc final public let surnames: Swift.String
  @objc final public let givenNames: Swift.String
  @objc final public let documentNumber: Swift.String
  @objc final public let nationality: Swift.String
  @objc final public let birthDate: Foundation.Date?
  @objc final public let sex: Swift.String?
  @objc final public let expiryDate: Foundation.Date?
  @objc final public let personalNumber: Swift.String
  @objc final public let personalNumber2: Swift.String?
  @objc final public let isDocumentNumberValid: Swift.Bool
  @objc final public let isBirthDateValid: Swift.Bool
  @objc final public let isExpiryDateValid: Swift.Bool
  @objc final public let isPersonalNumberValid: Swift.Bool
  @objc final public let allCheckDigitsValid: Swift.Bool
  @objc final public let lineCounts: [Swift.Int]
  @objc public var dictionary: [Swift.String : Swift.String] {
    @objc get
  }
  public var birthDateString: Swift.String? {
    get
  }
  public var expiryDateString: Swift.String? {
    get
  }
  @objc deinit
}
extension AesGcmNoPadding.Archive {
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func extract(_ entry: AesGcmNoPadding.Entry, to url: Foundation.URL, bufferSize: Swift.UInt32, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil) throws -> AesGcmNoPadding.CRC32
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func extract(_ entry: AesGcmNoPadding.Entry, bufferSize: Swift.UInt32, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> AesGcmNoPadding.CRC32
}
extension AesGcmNoPadding.Archive {
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: AesGcmNoPadding.CompressionMethod = .none, bufferSize: Swift.UInt32, progress: Foundation.Progress? = nil) throws
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func addEntry(with path: Swift.String, fileURL: Foundation.URL, compressionMethod: AesGcmNoPadding.CompressionMethod = .none, bufferSize: Swift.UInt32, progress: Foundation.Progress? = nil) throws
  @available(*, deprecated, message: "Please use `Int64` for `uncompressedSize` and provider `position`. `Int` for `bufferSize`.")
  final public func addEntry(with path: Swift.String, type: AesGcmNoPadding.Entry.EntryType, uncompressedSize: Swift.UInt32, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: AesGcmNoPadding.CompressionMethod = .none, bufferSize: Swift.Int = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data) throws
  @available(*, deprecated, message: "Please use `Int` for `bufferSize`.")
  final public func remove(_ entry: AesGcmNoPadding.Entry, bufferSize: Swift.UInt32, progress: Foundation.Progress? = nil) throws
}
extension Foundation.FileManager {
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool = true, compressionMethod: AesGcmNoPadding.CompressionMethod = .none, progress: Foundation.Progress? = nil) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, preferredEncoding: Swift.String.Encoding? = nil) throws
}
extension Foundation.URL {
  public func isContained(in parentDirectoryURL: Foundation.URL) -> Swift.Bool
}
